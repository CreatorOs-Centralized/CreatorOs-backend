package com.creatoros.assetservice.service;

import com.creatoros.assetservice.model.AssetFolder;
import com.creatoros.assetservice.model.MediaFile;
import com.creatoros.assetservice.model.MediaMetadata;
import com.creatoros.assetservice.model.MediaProcessingJob;
import com.creatoros.assetservice.repository.AssetFolderRepository;
import com.creatoros.assetservice.repository.MediaFileRepository;
import com.creatoros.assetservice.repository.MediaMetadataRepository;
import com.creatoros.assetservice.repository.MediaProcessingJobRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;
import com.google.cloud.storage.BlobId;
import com.google.cloud.storage.BlobInfo;
import com.google.cloud.storage.Storage;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class AssetService {

    private final Storage storage;
    private final MediaFileRepository mediaFileRepository;
    private final MediaMetadataRepository mediaMetadataRepository;
    private final AssetFolderRepository assetFolderRepository;
    private final MediaProcessingJobRepository mediaProcessingJobRepository;

    @Value("${gcp.bucket-name}")
    private String bucketName;

    @Transactional
    public MediaFile uploadFile(MultipartFile file, UUID userId, UUID folderId) throws IOException {
        assetFolderRepository.findByIdAndUserId(folderId, userId)
            .orElseThrow(() -> new RuntimeException("Folder not found: " + folderId));

        String fileName = file.getOriginalFilename();
        String storagePath = generateStoragePath(userId, folderId, fileName);

        // Upload to GCS
        log.info("Uploading file {} to bucket {} at path {}", fileName, bucketName, storagePath);
        BlobId blobId = BlobId.of(bucketName, storagePath);
        BlobInfo blobInfo = BlobInfo.newBuilder(blobId)
                .setContentType(file.getContentType())
                .build();

        storage.create(blobInfo, file.getBytes());

        // Create MediaFile entity
        // Note: ID is generated by DB to avoid Hibernate thinking this is a detached entity (OptimisticLockingException)
        MediaFile mediaFile = MediaFile.builder()
                .userId(userId)
                .folderId(folderId)
                .fileName(fileName)
                .originalFileName(fileName)
                .fileType(getFileExtension(fileName))
                .mimeType(file.getContentType())
                .sizeBytes(file.getSize())
                .storageProvider("GCS")
                .bucketName(bucketName)
                .storagePath(storagePath)
                .uploadStatus(MediaFile.UploadStatus.COMPLETED)
                .build();

        
        mediaFile = mediaFileRepository.save(mediaFile);

        // Update public URL with generated ID
        mediaFile.setPublicUrl(constructPublicUrl(mediaFile.getId()));
        mediaFile = mediaFileRepository.save(mediaFile);

        // Create initial Metadata
        MediaMetadata metadata = MediaMetadata.builder()
                .mediaFile(mediaFile)
                .extra(new HashMap<>())
                .build();
        mediaMetadataRepository.save(metadata);

        // Schedule Processing Job (e.g. for thumbnails)
        MediaProcessingJob job = MediaProcessingJob.builder()
                .mediaFile(mediaFile)
                .jobType("METADATA_EXTRACTION")
                .status(MediaProcessingJob.JobStatus.PENDING)
                .attempts(0)
                .build();
        mediaProcessingJobRepository.save(job);

        return mediaFile;
    }

    @Transactional
    public AssetFolder createFolder(String name, String description, UUID userId, UUID parentFolderId) {
        if (parentFolderId != null) {
            assetFolderRepository.findByIdAndUserId(parentFolderId, userId)
                    .orElseThrow(() -> new RuntimeException("Parent folder not found: " + parentFolderId));
        }

        AssetFolder folder = AssetFolder.builder()
                .name(name)
                .description(description)
                .userId(userId)
                .parentFolderId(parentFolderId)
                .build();
        return assetFolderRepository.save(folder);
    }

    public Map<String, Object> getFolderContents(UUID userId, UUID folderId) {
        List<AssetFolder> folders;
        List<MediaFile> files;

        if (folderId == null) {
            folders = assetFolderRepository.findByUserIdAndParentFolderIdIsNull(userId);
            // Assuming root files have a specific handling or just standard validation
            throw new IllegalArgumentException("Root listing not fully defined, please provide folderId"); 
        } else {
            folders = assetFolderRepository.findByUserIdAndParentFolderId(userId, folderId);
            files = mediaFileRepository.findByUserIdAndFolderId(userId, folderId);
        }

        Map<String, Object> contents = new HashMap<>();
        contents.put("folders", folders);
        contents.put("files", files);
        return contents;
    }
    
    public List<AssetFolder> getRootFolders(UUID userId) {
        return assetFolderRepository.findByUserIdAndParentFolderIdIsNull(userId);
    }

    private String generateStoragePath(UUID userId, UUID folderId, String fileName) {
        String safeFileName = UUID.randomUUID() + "-" + fileName.replaceAll("\\s+", "_");
        return String.format("%s/%s/%s", userId, folderId, safeFileName);
    }

    private String getFileExtension(String fileName) {
        if (fileName == null || fileName.lastIndexOf('.') == -1) {
            return "";
        }
        return fileName.substring(fileName.lastIndexOf('.') + 1);
    }

    private String constructPublicUrl(UUID fileId) {
        // Return the actual endpoint path where this file can be viewed
        // Frontends can prepend the domain (e.g., https://example.com/assets/view/{id})
        return String.format("/assets/view/%s", fileId);
    }
    
    public MediaFile getFileMetadata(UUID fileId, UUID userId) {
        return mediaFileRepository.findByIdAndUserId(fileId, userId)
                .orElseThrow(() -> new RuntimeException("File not found: " + fileId));
    }

    public org.springframework.core.io.Resource downloadFile(UUID fileId, UUID userId) throws IOException {
        MediaFile mediaFile = mediaFileRepository.findByIdAndUserId(fileId, userId)
                .orElseThrow(() -> new RuntimeException("File not found: " + fileId));
        
        BlobId blobId = BlobId.of(mediaFile.getBucketName(), mediaFile.getStoragePath());
        com.google.cloud.ReadChannel reader = storage.reader(blobId);
        
        return new org.springframework.core.io.InputStreamResource(java.nio.channels.Channels.newInputStream(reader)) {
            @Override
            public String getFilename() {
                return mediaFile.getFileName();
            }
            
            @Override
            public long contentLength() throws IOException {
                return mediaFile.getSizeBytes();
            }
        };
    }
}
